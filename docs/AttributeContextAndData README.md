<small>Back to Incremental Generator Extensions [README](../README.md)</small>

---
# AttributeContextAndData.cs, TypeContext.cs and AttributeContextAndDataExtensions.cs
Collecting rich, equality-stable information about each use of a marker attribute is a recurring pattern in incremental generators. These helpers standardise that pattern:
* `TypeContext` captures a type symbol plus its containing type chain (outermost → innermost) with stable value equality.
* `AttributeContextAndData<TData>` couples Roslyn attribute discovery with a strongly-typed payload you project once (constructor / named arguments, derived metadata, precomputed lookups, etc.).
* Extension methods wrap the low-level `ForAttributeWithMetadataName` plumbing so you focus on projecting meaningful data rather than repeatedly walking symbols.

### What You Get In `AttributeContextAndData<TData>`
* `AttributeData` (`TData`) – the payload: a minimal immutable projection of one attribute usage (raw Roslyn `AttributeData` is discarded after decoding).
* `Context` – the `TypeContext` for the directly attributed type.
* `ContainingTypes` – value‑equatable ordered chain of enclosing `TypeContext`s (outermost first).
* `CreateHintName(string generatorName)` – builds a stable, file‑safe hint including namespace, containing types and generic arity/type parameters.
* Convenience flags: `ContainingNamespaceIsGlobalNamespace`, `ContainingNamespaceDisplayString`, `HasContainingTypes`, `IsInFileScopedNamespace`, `IsNullableContextEnabled`.

### Why It Matters
* Stable value equality (type + containing chain + payload) short‑circuits downstream pipeline work.
* Single pass attribute argument decoding; you persist only the payload you need.

# Example Usage
```csharp
// 1. Marker attribute (in the consuming project)
[AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
public sealed class GenerateSomethingAttribute : Attribute
{
  public GenerateSomethingAttribute(string name, int version = 1)
  {
    Name = name; Version = version;
  }
  public string Name { get; }
  public int Version { get; }
}

// 2. Strongly-typed payload for one attribute usage
public sealed class GenerateSomethingData : IEquatable<GenerateSomethingData>
{
  public GenerateSomethingData(string name, int version)
  {
    Name = name;
    Version = version;
  }

  public string Name { get; }
  public int Version { get; }
  public bool Equals(GenerateSomethingData other) => other != null && Name == other.Name && Version == other.Version;
  public override bool Equals(object o) => Equals(o as GenerateSomethingData);
  public override int GetHashCode() => (Name ?? "").GetHashCode() ^ Version;

  // Factory used by SelectAttributeContexts (keeps generator focused on the pipeline)
  public static GenerateSomethingData Collect(Microsoft.CodeAnalysis.GeneratorAttributeSyntaxContext syntaxCtx)
  {
      var ad = syntaxCtx.Attributes[0];
      var ctorArgs = ad.ConstructorArguments;
      var name = (string)ctorArgs[0].Value;
      var version = ctorArgs.Length > 1 ? (int)ctorArgs[1].Value : 1;
      return new GenerateSomethingData(name, version);
  }
}

// 3. In your IncrementalGenerator.Initialize
const string AttributeMetadataName = "MyNamespace.GenerateSomethingAttribute"; // fully qualified metadata name

// Helper selects + transforms attribute usages into AttributeContextAndData<GenerateSomethingData>
var attributeUsages = context.SelectAttributeContexts(
  AttributeMetadataName,
  GenerateSomethingData.Collect);

// 4. Emit code (IndentingLineAppender for tidy formatting) – per usage
context.RegisterSourceOutput(attributeUsages, static (spc, usage) =>
{
    var ctx = usage.Context;                 // TypeContext of the attributed type
    var data = usage.AttributeData;          // Your projected payload (GenerateSomethingData)
    var hintName = usage.CreateHintName("GenerateSomething"); // Namespace + containing types + generics safe

    var ap = new IndentingLineAppender();
    ap.AppendLine("// <auto-generated>")
      .AppendLine("// demo")
      .AppendLine("// </auto-generated>")
      .AppendLine();

    // Minimal illustration: emit into the existing partial type (ignores namespace / containing types for brevity)
    ap.AppendLine(ctx.TypeDeclaration())
      .AppendStartBlock()
        .AppendLine($"public const int GeneratedVersion = {data.Version};")
      .AppendEndBlock();

    spc.AddSource(hintName, ap.ToString());
});
```

# Excluding the source files

To disable the inclusion of a specific source file,
define the relevant constant in the consuming project's `.csproj` file:

```XML
<PropertyGroup>
  <DefineConstants>$(DefineConstants);DATACUTE_EXCLUDE_ATTRIBUTECONTEXTANDDATA</DefineConstants>
  <DefineConstants>$(DefineConstants);DATACUTE_EXCLUDE_ATTRIBUTECONTEXTANDDATAEXTENSIONS</DefineConstants>
  <DefineConstants>$(DefineConstants);DATACUTE_EXCLUDE_TYPECONTEXT</DefineConstants>
</PropertyGroup>
```

The files will still appear in the project, but will not add anything to the compilation.

### Note: Dependencies
Direct:
* `AttributeContextAndDataExtensions.cs` -> `AttributeContextAndData.cs`
* `AttributeContextAndData.cs` -> `TypeContext.cs` (uses the type) and `EquatableImmutableArray.cs` (fields of `EquatableImmutableArray<TypeContext>`)

Transitive (implicit, not re‑stated as guards in the extensions file):
* `AttributeContextAndDataExtensions.cs` -> `TypeContext.cs`, `EquatableImmutableArray.cs` (only via `AttributeContextAndData.cs`)

Behavior:
* Core files (`AttributeContextAndData.cs`, `TypeContext.cs`) use fail‑fast `#error` directives if a required direct dependency is excluded.
* The extensions file only guards its direct dependency (the core `AttributeContextAndData`); if you exclude a transitive dependency the core file will produce the error and compilation will halt.

---
<small>
<small>
<small>
Datacute - Acute Information Revelation Tools
</small>
</small>
</small>