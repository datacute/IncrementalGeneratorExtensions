<small>Back to Incremental Generator Extensions [README](../README.md)</small>

---
# SourceTextGeneratorBase.cs

Base class that writes the routine wrapper code for a generated partial type: the auto‑generated comment, optional `#nullable enable`, namespace (file‑scoped or block), any containing types, the type declaration and braces. You just supply the inside members.

## Overview
`SourceTextGeneratorBase<T>` is created for each attribute usage (`AttributeContextAndData<T>`). It:
* Stores basic context (namespace, containing types, nullable, file‑scoped flag).
* Emits a simple header you can override.
* Calls overridable steps in a fixed order, then your `AppendCustomMembers()`.
* Closes everything and optionally lets you write diagnostics at the end.

It does not keep the full attribute payload itself; your subclass copies only what it needs.

## Typical Overrides
In practice you usually only override:
* `PrepareForGeneration()` – capture/copy payload data, clear or seed the buffer.
* `AppendDocComments()` – add XML docs before the type declaration (optional).
* `AppendCustomMembers()` – generate the body (fields / properties / methods).

Everything else has sensible defaults and is rarely touched.

## Execution Order (actual method body)
Below is the exact implementation from the base class (comments removed for brevity):

```csharp
protected virtual void AppendSource()
{
  PrepareForGeneration(); // override

  AppendAutoGeneratedComment();
  AppendNullableEnable();
  AppendStartNamespace();
  AppendContainingTypes();
  AppendDocComments();
  AppendTypeDeclaration();
  AppendStartBlock();

  AppendCustomMembers(); // override

  AppendEndBlock();
  AppendContainingTypesEndBlock();
  AppendEndNamespace();

  AppendDiagnosticLogs(); // defaults to NOP
}
```

## Example
Assume a marker attribute and payload already collected via `SelectAttributeContexts` (see `AttributeContextAndData` README).

```csharp
// Payload type
public sealed class GenerateSomethingData : IEquatable<GenerateSomethingData>
{
  public GenerateSomethingData(string name, int version) { Name = name; Version = version; }
  public string Name { get; }
  public int Version { get; }
  public bool Equals(GenerateSomethingData other) => other != null && Name == other.Name && Version == other.Version;
  public override bool Equals(object o) => Equals(o as GenerateSomethingData);
  public override int GetHashCode() => (Name ?? "").GetHashCode() ^ Version;
  public static GenerateSomethingData Collect(GeneratorAttributeSyntaxContext ctx)
  {
    var ad = ctx.Attributes[0];
    var args = ad.ConstructorArguments;
    return new GenerateSomethingData((string)args[0].Value, args.Length > 1 ? (int)args[1].Value : 1);
  }
}

// Concrete generator for one usage
sealed class GenerateSomethingSource : SourceTextGeneratorBase<GenerateSomethingData>
{
  private readonly GenerateSomethingData _data;
  public GenerateSomethingSource(
    in AttributeContextAndData<GenerateSomethingData> usage, 
    in CancellationToken token)
    : base(in usage, in token)
  {
    _data = usage.AttributeData;
  }

  protected override void AppendDocComments()
  {
    Buffer.AppendLine("/// <summary>")
        .AppendLine($"/// Generated members for '{_data.Name}'.")
        .AppendLine("/// </summary>");
  }

  protected override void AppendCustomMembers()
  {
    Buffer.AppendLine($"public const int GeneratedVersion = {_data.Version};");
  }

  protected override void AppendDiagnosticLogs()
  {
    Buffer.AppendLine();
    Buffer.Direct.AppendDiagnosticsComment(GeneratorStageDescriptions.GeneratorStageNameMap);
  }
}

// In IncrementalGenerator.Initialize
const string AttributeMetadataName = "MyNamespace.GenerateSomethingAttribute";
var usages = context.SelectAttributeContexts(AttributeMetadataName, GenerateSomethingData.Collect);

context.RegisterSourceOutput(usages, static (spc, usage) =>
{
  var gen = new GenerateSomethingSource(in usage, in spc.CancellationToken);
  spc.AddSource(usage.CreateHintName("GenerateSomething"), gen.GetSourceText());
});
```

# Excluding the source files

To disable the inclusion of a specific source file,
define the relevant constant in the consuming project's `.csproj` file:

```XML
<PropertyGroup>
  <DefineConstants>$(DefineConstants);DATACUTE_EXCLUDE_SOURCETEXTGENERATORBASE</DefineConstants>
</PropertyGroup>
```

The files will still appear in the project, but will not add anything to the compilation.

### Note: Dependencies
Direct:
* `SourceTextGeneratorBase.cs` -> `AttributeContextAndData.cs`, `TypeContext.cs`, `EquatableImmutableArray.cs`, `IndentingLineAppender.cs`

Transitive:
* `AttributeContextAndData.cs` itself depends (directly) on `TypeContext.cs` & `EquatableImmutableArray.cs` (already listed as direct here, so no hidden transitive chain beyond these)

Behavior:
* Fail‑fast `#error` directives are emitted if any direct dependency is excluded; this surfaces misconfiguration early.
* No additional guards for transitive items are needed since all are direct in this case.

---
<small>
<small>
<small>
Datacute - Acute Information Revelation Tools
</small>
</small>
</small>