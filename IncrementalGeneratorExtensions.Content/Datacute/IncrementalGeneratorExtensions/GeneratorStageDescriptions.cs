// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_GENERATORSTAGEDESCRIPTIONS && !DATACUTE_EXCLUDE_GENERATORSTAGE
using System.Collections.Generic;

namespace Datacute.IncrementalGeneratorExtensions
{
    /// <summary>
    /// Provides descriptions for various generator stages and counters used in incremental source generators.
    /// </summary>
    public static class GeneratorStageDescriptions
    {
        /// <summary>
        /// A dictionary mapping generator stages to their descriptive names.
        /// </summary>
        /// <example>
        /// This can be used to seed your own EventNameMap for tracing generator stages.
        /// (Use values >= 100 for your own events to avoid clashing.)   
        /// <code>
        /// EventNameMap = new Dictionary&lt;int, string&gt;(GeneratorStageDescriptions.GeneratorStageNameMap)
        /// {
        ///     { (int)MyCustomTrackingNamesEnum.MyCustomTracedEvent, "My Custom Traced Event" }
        /// }
        /// // elsewhere...
        /// LightweightTrace.GetCounts(_buffer, EventNameMap);
        /// LightweightTrace.GetTrace(_buffer, EventNameMap);
        /// </code>
        /// </example>
        public static readonly Dictionary<int, string> GeneratorStageNameMap = new Dictionary<int, string>
        {
            { (int)GeneratorStage.Initialize, "Generator Initialize" },
            { (int)GeneratorStage.Cancellation, "Operation Cancelled" },

            // Output registration stages
            { (int)GeneratorStage.RegisterPostInitializationOutput, "Register Post Initialization Output" },
            { (int)GeneratorStage.RegisterSourceOutput, "Register Source Output" },
            { (int)GeneratorStage.RegisterImplementationSourceOutput, "Register Implementation Source Output" },

            // PostInitializationContext Methods
            { (int)GeneratorStage.PostInitializationContextAddEmbeddedAttributeDefinition, "Post Initialization Context Add Embedded Attribute Definition" },
            { (int)GeneratorStage.PostInitializationContextAddSource, "Post Initialization Context Add Source" },

            // SourceProductionContext Methods
            { (int)GeneratorStage.SourceProductionContextAddSource, "Source Production Context Add Source" },
            { (int)GeneratorStage.SourceProductionContextReportDiagnostic, "Source Production Context Report Diagnostic" },

            // SyntaxProvider Methods
            { (int)GeneratorStage.CreateSyntaxProvider, "CreateSyntaxProvider Called" },
            { (int)GeneratorStage.ForAttributeWithMetadataNamePredicate, "ForAttributeWithMetadataName Predicate" },
            { (int)GeneratorStage.ForAttributeWithMetadataNameTransform, "ForAttributeWithMetadataName Transform" },
            { (int)GeneratorStage.ForAttributeWithMetadataName, "ForAttributeWithMetadataName Pipeline Output" },

            // Methods on various IncrementalValue(s) Providers
            { (int)GeneratorStage.CompilationProviderSelect, "CompilationProvider Select" },
            { (int)GeneratorStage.ParseOptionsProviderSelect, "ParseOptionsProvider Select" },
            { (int)GeneratorStage.AdditionalTextsProviderSelect, "AdditionalTextsProvider Select" },
            { (int)GeneratorStage.AnalyzerConfigOptionsProviderSelect, "AnalyzerConfigOptionsProvider Select" },
            { (int)GeneratorStage.MetadataReferencesProviderSelect, "MetadataReferencesProvider Select" },

#if !DATACUTE_EXCLUDE_EQUATABLEIMMUTABLEARRAY
            // EquatableImmutableArray Caching Metrics
            { (int)GeneratorStage.EquatableImmutableArrayCacheHit, "EquatableImmutableArray Cache Hit" },
            { (int)GeneratorStage.EquatableImmutableArrayCacheMiss, "EquatableImmutableArray Cache Miss" },
            { (int)GeneratorStage.EquatableImmutableArrayCacheWeakReferenceRemoved, "EquatableImmutableArray Cache Weak Reference Removed" },
            { (int)GeneratorStage.EquatableImmutableArrayLength, "EquatableImmutableArray Length" },
#endif
            
            { (int)GeneratorStage.MethodCall, "Method Call" },
            { (int)GeneratorStage.MethodEntry, "Method Entry" },
            { (int)GeneratorStage.MethodExit, "Method Exit" },
        };
    }
}
#endif