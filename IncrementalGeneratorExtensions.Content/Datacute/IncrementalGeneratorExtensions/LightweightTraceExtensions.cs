// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACEEXTENSIONS && !DATACUTE_EXCLUDE_LIGHTWEIGHT
using System;
using System.Threading;
using Microsoft.CodeAnalysis;

namespace Datacute.IncrementalGeneratorExtensions
{
    /// <summary>
    /// Extensions for <see cref="IncrementalValuesProvider{T}"/> and <see cref="IncrementalValueProvider{T}"/> to add tracing capabilities.
    /// </summary>
    /// <remarks>
    /// Also includes methods to trace and throw if a <see cref="CancellationToken"/> is cancelled.
    /// It is important to check for cancellation regularly within generators,
    /// as the user may have pressed a key, changing the source, and requiring the generation to restart.
    /// </remarks>
    public static class LightweightTraceExtensions
    {
        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValuesProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValuesProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnum">Type of the event ID enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValuesProvider{T}"/> to allow method chaining.</returns>
        /// <example>
        /// <code>
        /// var additionalTexts =
        ///     context.AdditionalTextsProvider
        ///            .Select(SelectFileInfo)
        ///            .WithTrackingName(GeneratorStage.AdditionalTextsProviderSelect)
        /// </code>
        /// </example>
        public static IncrementalValuesProvider<T> WithTrackingName<T, TEnum>(
            this IncrementalValuesProvider<T> source,
            TEnum eventId)
            where TEnum : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnum), eventId) ?? $"({eventId})");

        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValuesProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValuesProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <param name="value">An additional value to log with the event ID.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnum">Type of the event ID enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValuesProvider{T}"/> to allow method chaining.</returns>
        /// <example>
        /// <code>
        /// var slowSelection =
        ///     someIncrementalValuesProvider
        ///        .Select(Part1)
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, 1)
        ///        .CombineEquatable(dataToCombine)
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, 2)
        ///        .SelectMany(Part3)
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, 3)
        ///        .CollectEquatable()
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, 4)
        ///        .Select(Part5)
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, 5);
        /// </code>
        /// </example>
        public static IncrementalValuesProvider<T> WithTrackingName<T, TEnum>(
            this IncrementalValuesProvider<T> source,
            TEnum eventId,
            int value)
            where TEnum : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId, value);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnum), eventId) ?? $"({eventId})");

        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValuesProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValuesProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <param name="value">An additional value to log with the event ID.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnumKey">Type of the event ID enum.</typeparam>
        /// <typeparam name="TEnumValue">Type of the additional value enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValuesProvider{T}"/> to allow method chaining.</returns>
        /// <example>
        /// <code>
        /// var slowSelection =
        ///     someIncrementalValuesProvider
        ///        .Select(Part1)
        ///        .CombineEquatable(dataToCombine)
        ///        .SelectMany(Part3)
        ///        .CollectEquatable()
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, GeneratorStage.MethodEntry)
        ///        .Select(ComplicatedPart)
        ///        .WithTrackingName(YourCustomEnum.SlowPipeline, GeneratorStage.MethodExit);
        /// </code>
        /// </example>
        public static IncrementalValuesProvider<T> WithTrackingName<T, TEnumKey, TEnumValue>(
            this IncrementalValuesProvider<T> source,
            TEnumKey eventId,
            TEnumValue value)
            where TEnumKey : Enum
            where TEnumValue : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId, value);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnumKey), eventId) ?? $"({eventId})");

        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValueProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValueProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnum">Type of the event ID enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValueProvider{T}"/> to allow method chaining.</returns>
        public static IncrementalValueProvider<T> WithTrackingName<T, TEnum>(
            this IncrementalValueProvider<T> source,
            TEnum eventId)
            where TEnum : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnum), eventId) ?? $"({eventId})");

        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValueProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValueProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <param name="value">An additional value to log with the event ID.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnum">Type of the event ID enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValueProvider{T}"/> to allow method chaining.</returns>
        public static IncrementalValueProvider<T> WithTrackingName<T, TEnum>(
            this IncrementalValueProvider<T> source,
            TEnum eventId,
            int value)
            where TEnum : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId, value);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnum), eventId) ?? $"({eventId})");

        /// <summary>
        /// Extension of <see cref="IncrementalValueProviderExtensions.WithTrackingName{TSource}(Microsoft.CodeAnalysis.IncrementalValueProvider{TSource},string)"/>
        /// to trace the pipeline throughput, and to use an <see cref="Enum"/> as the event ID.
        /// </summary>
        /// <param name="source">The source <see cref="IncrementalValueProvider{T}"/>.</param>
        /// <param name="eventId">The event ID as an <see cref="Enum"/>.</param>
        /// <param name="value">An additional value to log with the event ID.</param>
        /// <typeparam name="T">Type of the values in the provider.</typeparam>
        /// <typeparam name="TEnumKey">Type of the event ID enum.</typeparam>
        /// <typeparam name="TEnumValue">Type of the additional value enum.</typeparam>
        /// <returns>The source <see cref="IncrementalValueProvider{T}"/> to allow method chaining.</returns>
        public static IncrementalValueProvider<T> WithTrackingName<T, TEnumKey, TEnumValue>(
            this IncrementalValueProvider<T> source,
            TEnumKey eventId,
            TEnumValue value)
            where TEnumKey : Enum
            where TEnumValue : Enum
            => source.Select((input, _) =>
            {
                LightweightTrace.Add(eventId, value);

                return input;
            }).WithTrackingName(Enum.GetName(typeof(TEnumKey), eventId) ?? $"({eventId})");

#if !DATACUTE_EXCLUDE_GENERATORSTAGE
        /// <summary>
        /// Throws an <see cref="OperationCanceledException"/> if the <see cref="CancellationToken"/> is cancelled,
        /// but first adds a trace entry for the cancellation with the specified <see cref="Enum"/>
        /// </summary>
        /// <param name="token">The <see cref="CancellationToken"/> to check for cancellation.</param>
        /// <param name="tracingInstanceEnum">The tracing instance enum to log with the cancellation event.</param>
        /// <typeparam name="TEnum">Type of the tracing instance enum.</typeparam>
        public static void ThrowIfCancellationRequested<TEnum>(
            this CancellationToken token,
            TEnum tracingInstanceEnum)
            where TEnum : Enum
        {
            if (token.IsCancellationRequested)
            {
                LightweightTrace.Add(GeneratorStage.Cancellation, tracingInstanceEnum);
            }
            token.ThrowIfCancellationRequested();
        }

        /// <summary>
        /// Throws an <see cref="OperationCanceledException"/> if the <see cref="CancellationToken"/> is cancelled,
        /// but first adds a trace entry for the cancellation with the specified id
        /// </summary>
        /// <param name="token">The <see cref="CancellationToken"/> to check for cancellation.</param>
        /// <param name="tracingInstanceId">The tracing instance id to log with the cancellation event.</param>
        /// <remarks>
        /// This method is intended for quick debugging using simple numeric identifiers to see which cancellation check was hit,
        /// </remarks>
        public static void ThrowIfCancellationRequested(
            this CancellationToken token,
            int tracingInstanceId)
        {
            if (token.IsCancellationRequested)
            {
                LightweightTrace.Add(GeneratorStage.Cancellation, tracingInstanceId);
            }
            token.ThrowIfCancellationRequested();
        }
#endif
    }
}
#endif