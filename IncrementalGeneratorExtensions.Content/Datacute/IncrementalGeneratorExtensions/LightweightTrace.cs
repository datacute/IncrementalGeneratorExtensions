// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace Datacute.IncrementalGeneratorExtensions
{
    public static class LightweightTrace
    {
        private const int Capacity = 1024;
        private const int KeyValueShift = 1024;

        private static readonly DateTime StartTime = DateTime.UtcNow;
        private static readonly Stopwatch Stopwatch = Stopwatch.StartNew();

        private static readonly (long, int)[] Events = new (long, int)[Capacity];
        private static int _index;

        public static void Add<TEnum>(TEnum eventId) where TEnum : Enum => Add(Convert.ToInt32(eventId));
        public static void Add<TEnum>(TEnum eventId, int value) where TEnum : Enum => Add(Convert.ToInt32(eventId) + value * KeyValueShift);
        public static void Add(int eventId, int value) => Add(eventId + value * KeyValueShift);
        public static void Add(int eventId)
        {
            var index = Interlocked.Increment(ref _index) % Capacity;
            Events[index] = (Stopwatch.ElapsedTicks, eventId);
            IncrementCount(eventId);
        }

        public static void AppendTrace(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            var index = _index;
            for (var i = 0; i < Capacity; i++)
            {
                index = (index + 1) % Capacity;
                var (timestamp, eventId) = Events[index];
                if (timestamp > 0)
                {
                    var textAndValue = GetTextAndValue(eventNameMap, eventId);
                    stringBuilder.AppendFormat("{0:o} [{1:000}] {2}",
                            StartTime.AddTicks(timestamp),
                            eventId % KeyValueShift,
                            textAndValue)
                        .AppendLine();
                }
            }
        }

        private static readonly ConcurrentDictionary<int, long> Counters = new ConcurrentDictionary<int, long>();

        /// <summary>
        /// Increments the value of a given key by 1.
        /// </summary>
        public static void IncrementCount<TEnum>(TEnum counterId) where TEnum : Enum => IncrementCount(Convert.ToInt32(counterId));
        public static void IncrementCount<TEnum>(TEnum counterId, int value) where TEnum : Enum => IncrementCount(Convert.ToInt32(counterId), value);

        /// <summary>
        /// Decrements the value of a given key by 1.
        /// </summary>
        public static void DecrementCount<TEnum>(TEnum counterId) where TEnum : Enum => DecrementCount(Convert.ToInt32(counterId));
        public static void DecrementCount<TEnum>(TEnum counterId, int value) where TEnum : Enum => DecrementCount(Convert.ToInt32(counterId), value);

        /// <summary>
        /// Increments the value of a given key by 1.
        /// </summary>
        public static void IncrementCount(int counterId) => Counters.AddOrUpdate(counterId, 1, (_, count) => count + 1);
        public static void IncrementCount(int counterId, int value) => Counters.AddOrUpdate(counterId + value * KeyValueShift, 1, (_, count) => count + 1);

        /// <summary>
        /// Decrements the value of a given key by 1.
        /// </summary>
        public static void DecrementCount(int counterId) => Counters.AddOrUpdate(counterId, -1, (_, count) => count - 1);
        public static void DecrementCount(int counterId, int value) => Counters.AddOrUpdate(counterId + value * KeyValueShift, -1, (_, count) => count - 1);

        /// <summary>
        /// Gets a string with the current cache performance metrics.
        /// It intelligently separates simple counters from histogram data based on key prefixes.
        /// </summary>
        public static void AppendCounts(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            // Order by key for a consistent, readable output
            foreach (var kvp in Counters.OrderBy(kvp => kvp.Key % KeyValueShift).ThenBy(kvp => kvp.Key))
            {
                int counterId = kvp.Key;
                long count = kvp.Value;

                var textAndValue = GetTextAndValue(eventNameMap, counterId);
                stringBuilder.AppendFormat(
                    "[{0:000}] {1}: {2}", 
                    counterId % KeyValueShift, textAndValue, count)
                    .AppendLine();
            }
        }

        private static string GetTextAndValue(Dictionary<int, string> eventNameMap, int key)
        {
            int id = key % KeyValueShift;
            int value = key / KeyValueShift;

            string text  = null;
            if (eventNameMap != null)
            {
                eventNameMap.TryGetValue(id, out text);
            }
            if (text == null)
            {
                text = string.Empty;
            }
            return (key > KeyValueShift) ? $"{text} ({value})" : text;
        }

        /// <summary>
        /// Append a comment containing all the diagnostic counters and logs to the StringBuilder.
        /// </summary>
        /// <param name="stringBuilder">The StringBuilder to append the diagnostics comment to.</param>
        /// <param name="eventNameMap">A dictionary mapping event IDs to their names, used for more readable output.</param>
        /// <example>
        ///
        /// </example>
        public static void AppendDiagnosticsComment(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            stringBuilder.AppendLine("/* Diagnostics");
            stringBuilder.AppendLine("Counters:");
            stringBuilder.AppendCounts(eventNameMap);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("Trace Log:");
            stringBuilder.AppendTrace(eventNameMap);
            stringBuilder.AppendLine("*/");
        }
    }
}
#endif