// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;

namespace Datacute.IncrementalGeneratorExtensions
{
    public static class LightweightTrace
    {
        private const int Capacity = 1024;

        private static readonly DateTime StartTime = DateTime.UtcNow;
        private static readonly Stopwatch Stopwatch = Stopwatch.StartNew();

        private static readonly (long, int)[] Events = new (long, int)[Capacity];
        private static int _index;

        public static void Add<TEnum>(TEnum eventId) where TEnum : Enum => Add(Convert.ToInt32(eventId));

        public static void Add(int eventId)
        {
            var index = Interlocked.Increment(ref _index) % Capacity;
            Events[index] = (Stopwatch.ElapsedTicks, eventId);
            IncrementCount(eventId);
        }

        public static void AppendTrace(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            var index = _index;
            for (var i = 0; i < Capacity; i++)
            {
                index = (index + 1) % Capacity;
                var (timestamp, eventId) = Events[index];
                if (timestamp > 0)
                {
                    var item = string.Empty;
                    if (eventId > 1000)
                    {
                        item = $" ({eventId / 1000})";
                    }
                    
                    string text  = null;
                    if (eventNameMap != null)
                    {
                        eventNameMap.TryGetValue(eventId % 1000, out text);
                    }
                    if (text == null)
                    {
                        text = string.Empty;
                    }

                    stringBuilder.AppendFormat("{0:o} [{1:000}] {2} {3}",
                            StartTime.AddTicks(timestamp),
                            eventId % 1000,
                            text,
                            item)
                        .AppendLine();
                }
            }
        }

        private static readonly ConcurrentDictionary<int, long> Counters = new ConcurrentDictionary<int, long>();

        /// <summary>
        /// Increments the value of a given key by 1.
        /// </summary>
        public static void IncrementCount<TEnum>(TEnum counterId) where TEnum : Enum => IncrementCount(Convert.ToInt32(counterId));

        /// <summary>
        /// Decrements the value of a given key by 1.
        /// </summary>
        public static void DecrementCount<TEnum>(TEnum counterId) where TEnum : Enum => DecrementCount(Convert.ToInt32(counterId));

        /// <summary>
        /// Increments the value of a given key by 1.
        /// </summary>
        public static void IncrementCount(int counterId) => Counters.AddOrUpdate(counterId, 1, (_, count) => count + 1);

        /// <summary>
        /// Decrements the value of a given key by 1.
        /// </summary>
        public static void DecrementCount(int counterId) => Counters.AddOrUpdate(counterId, -1, (_, count) => count - 1);

        /// <summary>
        /// Gets a string with the current cache performance metrics.
        /// It intelligently separates simple counters from histogram data based on key prefixes.
        /// </summary>
        public static void AppendCounts(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            // Order by key for a consistent, readable output
            foreach (var kvp in Counters.OrderBy(kvp => kvp.Key % 1000).ThenBy(kvp => kvp.Key))
            {
                int counterId = kvp.Key;
                long count = kvp.Value;

                var item = string.Empty;
                if (counterId > 1000)
                {
                    item = $" ({counterId / 1000})";
                }
                string text  = null;
                if (eventNameMap != null)
                {
                    eventNameMap.TryGetValue(counterId % 1000, out text);
                }
                if (text == null)
                {
                    text = string.Empty;
                }
                stringBuilder.AppendFormat(
                    "[{0:000}] {1}{2}: {3}", 
                    counterId % 1000, text, item, count)
                    .AppendLine();
            }
        }

        public static void AppendDiagnosticsComment(this StringBuilder stringBuilder, Dictionary<int, string> eventNameMap = null)
        {
            if (stringBuilder is null)
            {
                return;
            }

            stringBuilder.AppendLine("/* Diagnostics");
            stringBuilder.AppendLine("Counters:");
            stringBuilder.AppendCounts(eventNameMap);
            stringBuilder.AppendLine();
            stringBuilder.AppendLine("Trace Log:");
            stringBuilder.AppendTrace(eventNameMap);
            stringBuilder.AppendLine("*/");
        }
    }
}
#endif