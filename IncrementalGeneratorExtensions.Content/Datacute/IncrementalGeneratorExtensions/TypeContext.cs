// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_TYPECONTEXT && !DATACUTE_EXCLUDE_EQUATABLEIMMUTABLEARRAY
using System;
using System.Linq;
using Microsoft.CodeAnalysis;

namespace Datacute.IncrementalGeneratorExtensions
{
    public readonly struct TypeContext : IEquatable<TypeContext>
    {
        public string Name { get; }
        public bool IsStatic { get; }
        public Accessibility Accessibility { get; }
        public string RecordStructOrClass { get; }
        public EquatableImmutableArray<string> TypeParameterNames { get; }

        public TypeContext(string name, 
            bool isStatic, 
            Accessibility accessibility,
            string recordStructOrClass,
            EquatableImmutableArray<string> typeParameterNames)
        {
            Name = name;
            IsStatic = isStatic;
            Accessibility = accessibility;
            RecordStructOrClass = recordStructOrClass;
            TypeParameterNames = typeParameterNames;
        }

        public bool Equals(TypeContext other)
        {
            return Name == other.Name && IsStatic == other.IsStatic && Accessibility == other.Accessibility && RecordStructOrClass == other.RecordStructOrClass && Equals(TypeParameterNames, other.TypeParameterNames);
        }

        public override bool Equals(object obj)
        {
            return obj is TypeContext other && Equals(other);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = (Name != null ? Name.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ IsStatic.GetHashCode();
                hashCode = (hashCode * 397) ^ (int)Accessibility;
                hashCode = (hashCode * 397) ^ (RecordStructOrClass != null ? RecordStructOrClass.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (TypeParameterNames != null ? TypeParameterNames.GetHashCode() : 0);
                return hashCode;
            }
        }
        
        public string PartialTypeDeclaration()
        {
            return string.Format(
                "{0}{1}partial {2} {3}{4}",
                GetAccessibilityModifier(),
                GetStaticModifier(),
                RecordStructOrClass,
                Name,
                GetGenericTypes()
            );
        }
        
        public string TypeDeclaration()
        {
            return string.Format(
                "{0}{1}{2} {3}{4}",
                GetAccessibilityModifier(),
                GetStaticModifier(),
                RecordStructOrClass,
                Name,
                GetGenericTypes()
            );
        }
        
        public string GetAccessibilityModifier() => GetAccessibilityModifier(Accessibility);

        public static string GetAccessibilityModifier(Accessibility accessibility)
        {
            switch (accessibility)
            {
                case Accessibility.Private:
                    return "private ";
                case Accessibility.ProtectedAndInternal:
                    return "private protected ";
                case Accessibility.Protected:
                    return "protected ";
                case Accessibility.Internal:
                    return "internal ";
                case Accessibility.ProtectedOrInternal:
                    return "protected internal ";
                case Accessibility.Public:
                    return "public ";
                default:
                    throw new ArgumentOutOfRangeException(nameof(accessibility), accessibility, null);
            }
        }
        
        public string GetStaticModifier() => GetStaticModifier(IsStatic);
        public static string GetStaticModifier(bool isStatic) => isStatic ? "static " : "";
        
        public static string GetRecordStructOrClass(ITypeSymbol typeSymbol)
        {
            if (typeSymbol.IsRecord && typeSymbol.IsReferenceType)
                return "record";
            if (typeSymbol.IsRecord)
                return "record struct";
            if (typeSymbol.IsReferenceType)
                return "class";
            return "struct";
        }

        public string GetGenericTypes() => GetGenericTypes(TypeParameterNames);

        public static string GetGenericTypes(EquatableImmutableArray<string> genericTypes) =>
            genericTypes.Any()
                ? $"<{string.Join(",", genericTypes)}>"
                : string.Empty;
    }
}
#endif