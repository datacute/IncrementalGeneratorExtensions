// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_ATTRIBUTECONTEXTANDDATA && !DATACUTE_EXCLUDE_TYPECONTEXT
using System;
using System.Collections.Immutable;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Datacute.IncrementalGeneratorExtensions
{
    /// <summary>
    /// Represents the context and data of an attribute in a source generator.
    /// </summary>
    /// <typeparam name="T">The type of the attribute data, which must implement <see cref="IEquatable{T}"/>.</typeparam>
    public readonly struct AttributeContextAndData<T> : IEquatable<AttributeContextAndData<T>> 
        where T : IEquatable<T>
    {
        /// <summary>
        /// Indicates whether the containing namespace is the global namespace.
        /// </summary>
        public readonly bool ContainingNamespaceIsGlobalNamespace;
        /// <summary>
        /// The display string of the containing namespace.
        /// </summary>
        public readonly string ContainingNamespaceDisplayString;
        /// <summary>
        /// The context of the type to which the attribute is applied.
        /// </summary>
        public readonly TypeContext Context;
        /// <summary>
        /// A collection of contexts for the containing types of the attribute's target symbol.
        /// </summary>
        public readonly EquatableImmutableArray<TypeContext> ContainingTypes;
        
        /// <summary>
        /// The display string of the attribute's target symbol, formatted as Namespace.ClassName.
        /// </summary>
        /// <remarks>
        /// This string is useful for generating a hint name for the attribute, as it provides a
        /// fully qualified name that includes the namespace and class name.
        /// </remarks>
        public readonly string DisplayString;

        /// <summary>
        /// Indicates whether the attribute's target symbol has any containing types.
        /// </summary>
        public bool HasContainingTypes => ContainingTypes.Length > 0;

        /// <summary>
        /// The data associated with the attribute, which is typically collected from the attribute's syntax context.
        /// </summary>
        public readonly T AttributeData;

        /// <summary>
        /// Initializes a new instance of the <see cref="AttributeContextAndData{T}"/> struct.
        /// </summary>
        /// <param name="generatorAttributeSyntaxContext">The context of the attribute syntax, which includes information about the target symbol and the attribute itself.</param>
        /// <param name="attributeData">The data associated with the attribute, typically collected from the attribute's syntax context.</param>
        public AttributeContextAndData(in GeneratorAttributeSyntaxContext generatorAttributeSyntaxContext, in T attributeData)
        {
            AttributeData = attributeData;

            // No diagnostic tracing here - this triggers for each matching attribute, every time you type.
            // the time taken within this method is about 1% of the time the source generator takes
            // to process the attribute.

            var attributeTargetSymbol = (ITypeSymbol)generatorAttributeSyntaxContext.TargetSymbol;

            ContainingNamespaceIsGlobalNamespace = attributeTargetSymbol.ContainingNamespace.IsGlobalNamespace;
            ContainingNamespaceDisplayString = attributeTargetSymbol.ContainingNamespace.ToDisplayString();

            EquatableImmutableArray<string> typeParameterNames;
            if (generatorAttributeSyntaxContext.TargetSymbol is INamedTypeSymbol namedTypeTargetSymbol)
            {
                ImmutableArray<ITypeParameterSymbol> typeParameters = namedTypeTargetSymbol.TypeParameters;
                typeParameterNames = typeParameters.Length > 0
                    ? typeParameters.ToEquatableImmutableArray(tp => tp.Name)
                    : EquatableImmutableArray<string>.Empty;
            }
            else
            {
                typeParameterNames = EquatableImmutableArray<string>.Empty;
            }

            Context = new TypeContext(
                attributeTargetSymbol.Name,
                attributeTargetSymbol.IsStatic,
                attributeTargetSymbol.DeclaredAccessibility,
                TypeContext.GetRecordStructOrClass(attributeTargetSymbol),
                typeParameterNames);

            DisplayString = attributeTargetSymbol.ToDisplayString();
        
            // Parse parent classes from symbol's containing types
            var parentClassCount = 0;
            var containingType = attributeTargetSymbol.ContainingType;
            // Count the number of parent classes
            while (containingType != null)
            {
                parentClassCount++;
                containingType = containingType.ContainingType;
            }

            if (parentClassCount > 0)
            {
                containingType = attributeTargetSymbol.ContainingType;
                var containingTypesImmutableArrayBuilder = ImmutableArray.CreateBuilder<TypeContext>(parentClassCount);
                for (var i = 0; i < parentClassCount; i++)
                {
                    var typeParameters = containingType.TypeParameters;
                    var containingTypeTypeParameterNames = typeParameters.Length > 0
                        ? typeParameters.ToEquatableImmutableArray(tp => tp.Name)
                        : EquatableImmutableArray<string>.Empty;

                    containingTypesImmutableArrayBuilder.Insert(0, new TypeContext(
                        containingType.Name, 
                        containingType.IsStatic,
                        containingType.DeclaredAccessibility,
                        TypeContext.GetRecordStructOrClass(containingType),
                        containingTypeTypeParameterNames));
                    containingType = containingType.ContainingType;
                }

                ContainingTypes = containingTypesImmutableArrayBuilder.MoveToImmutable().ToEquatableImmutableArray();
            }
            else
            {
                ContainingTypes = EquatableImmutableArray<TypeContext>.Empty;
            }
        }

        /// <inheritdoc />
        public bool Equals(AttributeContextAndData<T> other)
        {
            return ContainingNamespaceIsGlobalNamespace == other.ContainingNamespaceIsGlobalNamespace && ContainingNamespaceDisplayString == other.ContainingNamespaceDisplayString && Context.Equals(other.Context) && Equals(ContainingTypes, other.ContainingTypes) && DisplayString == other.DisplayString && AttributeData.Equals(other.AttributeData);
        }

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            return obj is AttributeContextAndData<T> other && Equals(other);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            unchecked
            {
                var hashCode = ContainingNamespaceIsGlobalNamespace.GetHashCode();
                hashCode = (hashCode * 397) ^ (ContainingNamespaceDisplayString != null ? ContainingNamespaceDisplayString.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ Context.GetHashCode();
                hashCode = (hashCode * 397) ^ (ContainingTypes != null ? ContainingTypes.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (DisplayString != null ? DisplayString.GetHashCode() : 0);
                hashCode = (hashCode * 397) ^ (AttributeData != null ? AttributeData.GetHashCode() : 0);
                return hashCode;
            }
        }
        
        /// <summary>
        /// Predicate to determine if the syntax node is a type declaration syntax.
        /// </summary>
        /// <param name="syntaxNode">The syntax node to check.</param>
        /// <param name="token">The cancellation token to observe for cancellation requests.</param>
        /// <returns> True if the syntax node is a type declaration syntax, otherwise false.</returns>
        /// <example>
        /// <code lang="csharp">
        /// context.SyntaxProvider
        ///     .ForAttributeWithMetadataName(
        ///         "YourFullyQualifiedMetadataName",
        ///         predicate: AttributeContextAndData&lt;YourAttributeDataType&gt;.Predicate,
        ///         transform: (syntaxContext, token) =>
        ///             AttributeContextAndData&lt;YourAttributeDataType&gt;.Transform(syntaxContext, yourAttributeDataCollector, token))
        ///     .WithTrackingName(GeneratorStage.ForAttributeWithMetadataName);
        /// </code>
        /// </example>
        /// <seealso cref="AttributeContextAndDataExtensions.SelectAttributeContexts{T}"/>
        public static bool Predicate(SyntaxNode syntaxNode, CancellationToken token)
        {
#if !DATACUTE_EXCLUDE_GENERATORSTAGE && !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
            LightweightTrace.IncrementCount(GeneratorStage.ForAttributeWithMetadataNamePredicate);
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACEEXTENSIONS
            token.ThrowIfCancellationRequested(GeneratorStage.ForAttributeWithMetadataNamePredicate);
#else
            token.ThrowIfCancellationRequested();
#endif
#endif
            return syntaxNode is TypeDeclarationSyntax;
        }

        /// <summary>
        /// Transforms the <see cref="GeneratorAttributeSyntaxContext"/> into an <see cref="AttributeContextAndData{T}"/> instance.
        /// </summary>
        /// <param name="generatorAttributeSyntaxContext">The context of the attribute syntax, which includes information about the target symbol and the attribute itself.</param>
        /// <param name="attributeDataCollector">A function that collects the attribute data from the <see cref="GeneratorAttributeSyntaxContext"/>.</param>
        /// <param name="token">The cancellation token to observe for cancellation requests.</param>
        /// <returns>An instance of <see cref="AttributeContextAndData{T}"/> containing the attribute context and data.</returns>
        /// <example>
        /// <code lang="csharp">
        /// context.SyntaxProvider
        ///     .ForAttributeWithMetadataName(
        ///         "YourFullyQualifiedMetadataName",
        ///         predicate: AttributeContextAndData&lt;YourAttributeDataType&gt;.Predicate,
        ///         transform: (syntaxContext, token) =>
        ///             AttributeContextAndData&lt;YourAttributeDataType&gt;.Transform(syntaxContext, yourAttributeDataCollector, token))
        ///     .WithTrackingName(GeneratorStage.ForAttributeWithMetadataName);
        /// </code>
        /// </example>
        /// <seealso cref="AttributeContextAndDataExtensions.SelectAttributeContexts{T}"/>
        public static AttributeContextAndData<T> Transform(GeneratorAttributeSyntaxContext generatorAttributeSyntaxContext, Func<GeneratorAttributeSyntaxContext, T> attributeDataCollector, CancellationToken token)
        {
#if !DATACUTE_EXCLUDE_GENERATORSTAGE && !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
            LightweightTrace.IncrementCount(GeneratorStage.ForAttributeWithMetadataNameTransform);
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACEEXTENSIONS
            token.ThrowIfCancellationRequested(GeneratorStage.ForAttributeWithMetadataNameTransform);
#else
            token.ThrowIfCancellationRequested();
#endif
#endif
            T attributeData = attributeDataCollector(generatorAttributeSyntaxContext);
            var attributeContextAndData = new AttributeContextAndData<T>(generatorAttributeSyntaxContext, attributeData);
            return attributeContextAndData;
        }
    }
}
#endif