// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_EQUATABLEIMMUTABLEARRAY
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading;

namespace Datacute.IncrementalGeneratorExtensions
{
    /// <summary>
    /// Represents an immutable array that implements IEquatable for value equality.
    /// </summary>
    /// <typeparam name="T">The type of elements in the array, which must implement IEquatable&lt;T&gt;.</typeparam>
    public sealed class EquatableImmutableArray<T> : IEquatable<EquatableImmutableArray<T>>, IReadOnlyList<T>
        where T : IEquatable<T>
    {
        public static EquatableImmutableArray<T> Empty { get; } = new EquatableImmutableArray<T>(ImmutableArray<T>.Empty, 0);

        // The source generation pipelines compare these a lot
        // so being able to quickly tell when they are different
        // is important.
        // We will use an instance cache to find when we can reuse
        // an existing object, massively speeding up the Equals call.
        #region Instance Cache

        // The WeakReference allows the GC to collect arrays that are no longer in use.
        // Thread-safe cache using dictionary of hash code -> list of arrays with that hash
        private static readonly ConcurrentDictionary<int, List<WeakReference<EquatableImmutableArray<T>>>> ValueCache = new ConcurrentDictionary<int, List<WeakReference<EquatableImmutableArray<T>>>>();

        // Static factory method with singleton handling
        public static EquatableImmutableArray<T> Create(ImmutableArray<T> values, CancellationToken cancellationToken = default)
        {
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
            // Record a histogram of the array sizes we are being asked to create
            LightweightTrace.IncrementCount(values.Length * 1000 + 300);
#endif
            if (values.IsEmpty)
                return Empty;

            var hash = CalculateHashCode(values);
            var list = ValueCache.GetOrAdd(hash, _ => new List<WeakReference<EquatableImmutableArray<T>>>());

            lock (list)
            {
                for (int i = list.Count - 1; i >= 0; i--)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    if (list[i].TryGetTarget(out var existing))
                    {
                        if (ValuesEqual(values, existing._values))
                        {
                            // Cache Hit
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
                            LightweightTrace.IncrementCount(300);
#endif
                            return existing;
                        }
                    }
                    else
                    {
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
                        LightweightTrace.IncrementCount(302);
#endif
                        list.RemoveAt(i);
                    }
                }

                // Cache Miss: Create a new instance
#if !DATACUTE_EXCLUDE_LIGHTWEIGHTTRACE
                LightweightTrace.IncrementCount(301);
#endif
                var newResult = new EquatableImmutableArray<T>(values, hash);
                list.Add(new WeakReference<EquatableImmutableArray<T>>(newResult));
                return newResult;
            }
        }

        private static int CalculateHashCode(ImmutableArray<T> values)
        {
            var comparer = EqualityComparer<T>.Default;
            var hash = 0;
            for (var index = 0; index < values.Length; index++)
            {
                var value = values[index];
                hash = HashHelpers_Combine(hash, value == null ? 0 : comparer.GetHashCode(value));
            }
            return hash;
        }
        
        private static int HashHelpers_Combine(int h1, int h2)
        {
            // RyuJIT optimizes this to use the ROL instruction
            // Related GitHub pull request: https://github.com/dotnet/coreclr/pull/1830
            uint rol5 = ((uint)h1 << 5) | ((uint)h1 >> 27);
            return ((int)rol5 + h1) ^ h2;
        }

        private static bool ValuesEqual(ImmutableArray<T> a, ImmutableArray<T> b)
        {
            // Identical arrays reference check
            if (a == b) return true;
            
            int length = a.Length;
            if (length != b.Length) return false;
            
            var comparer = EqualityComparer<T>.Default;
            for (int i = 0; i < length; i++)
            {
                if (!comparer.Equals(a[i], b[i]))
                    return false;
            }
            
            return true;
        }
        
        #endregion

        private readonly ImmutableArray<T> _values;
        private readonly int _hashCode;
        private readonly int _length;
        public T this[int index] => _values[index];
        public int Count => _length;
        
        // Properties Duplicated from ImmutableArray<T>
        public int Length => _length;
        public bool IsEmpty => _length == 0;
        public bool IsDefault => _values.IsDefault;
        public bool IsDefaultOrEmpty => _values.IsDefaultOrEmpty;

        private EquatableImmutableArray(ImmutableArray<T> values, int hashCode)
        {
            _values = values;
            _length = values.Length;
            _hashCode = hashCode;
        }
        
        public bool Equals(EquatableImmutableArray<T> other)
        {
            // Fast reference equality check
            if (ReferenceEquals(this, other)) return true;

            if (other is null) return false;

            // If hash codes are different, arrays can't be equal
            if (_hashCode != other._hashCode) return false;

            // We're really unlikely to get here, as we're using an instance cache
            // so we've probably encountered a hash collision
            
            // Compare array lengths
            if (_length != other._length) return false;

            // If both are empty, they're equal
            if (_length == 0) return true;

            // Element-by-element comparison
            var comparer = EqualityComparer<T>.Default;
            for (int i = 0; i < _length; i++)
            {
                if (!comparer.Equals(_values[i], other._values[i]))
                    return false;
            }

            return true;
        }

        public override bool Equals(object obj) => obj is EquatableImmutableArray<T> other && Equals(other);

        public override int GetHashCode() => _hashCode;

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => ((IEnumerable<T>)_values).GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable)_values).GetEnumerator();
    }
}
#endif