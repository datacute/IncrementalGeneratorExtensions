// <auto-generated>
// This file is part of the Datacute.IncrementalGeneratorExtensions package.
// It is included as a source file and should not be modified.
// </auto-generated>

#if !DATACUTE_EXCLUDE_EQUATABLEIMMUTABLEARRAY
using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading;

namespace Datacute.IncrementalGeneratorExtensions
{
    /// <summary>
    /// Represents an immutable array that implements IEquatable for value equality.
    /// </summary>
    /// <typeparam name="T">The type of elements in the array, which must implement IEquatable&lt;T&gt;.</typeparam>
    public sealed class EquatableImmutableArray<T> : IEquatable<EquatableImmutableArray<T>>, IReadOnlyList<T>
        where T : IEquatable<T>
    {
        public static EquatableImmutableArray<T> Empty { get; } = new EquatableImmutableArray<T>(ImmutableArray<T>.Empty, 0);

        // Static factory method with singleton handling
        public static EquatableImmutableArray<T> Create(ImmutableArray<T> values, CancellationToken cancellationToken = default) 
            => EquatableImmutableArrayInstanceCache<T>.GetOrCreate(values, cancellationToken);

        private readonly ImmutableArray<T> _values;
        private readonly int _hashCode;
        private readonly int _length;

        public T this[int index] => _values[index];
        public int Count => _length;
        
        // Properties Duplicated from ImmutableArray<T>
        public int Length => _length;
        public bool IsEmpty => _length == 0;
        public bool IsDefault => _values.IsDefault;
        public bool IsDefaultOrEmpty => _values.IsDefaultOrEmpty;

        internal EquatableImmutableArray(ImmutableArray<T> values, int hashCode)
        {
            _values = values;
            _length = values.Length;
            _hashCode = hashCode;
        }
        
        public bool Equals(EquatableImmutableArray<T> other)
        {
            // Fast reference equality check
            if (ReferenceEquals(this, other)) return true;

            if (other is null) return false;

            // If hash codes are different, arrays can't be equal
            if (_hashCode != other._hashCode) return false;

            // We're really unlikely to get here, as we're using an instance cache
            // so we've probably encountered a hash collision
            
            // Compare array lengths
            if (_length != other._length) return false;

            // If both are empty, they're equal
            if (_length == 0) return true;

            // Element-by-element comparison
            var comparer = EqualityComparer<T>.Default;
            for (int i = 0; i < _length; i++)
            {
                if (!comparer.Equals(_values[i], other._values[i]))
                    return false;
            }

            return true;
        }

        public override bool Equals(object obj) => obj is EquatableImmutableArray<T> other && Equals(other);

        public override int GetHashCode() => _hashCode;

        IEnumerator<T> IEnumerable<T>.GetEnumerator() => ((IEnumerable<T>)_values).GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => ((IEnumerable)_values).GetEnumerator();
    }
}
#endif